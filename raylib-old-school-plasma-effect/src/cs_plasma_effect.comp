#version 460

// layout( binding = 0,rgba8) uniform coherent image2D u_image;
 layout( binding = 0,rgba8) uniform coherent image2D u_input_image;
 layout( binding = 1,rgba8) uniform coherent image2D u_output_image;

 

 layout(location = 3) uniform float time;
 layout(location = 4) uniform vec2 frequency;

 
float PI_2 = 6.28;
 
layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;
void main()
{

	ivec2 size = imageSize(u_input_image);
    ivec2 pixel_screen_coord = ivec2( gl_GlobalInvocationID.x,  gl_GlobalInvocationID.y);

	/*
	int pixel_size = 4;
	float xx = pixel_screen_coord.x ;
	xx/= pixel_size;
	float yy = pixel_screen_coord.y ;
	yy/=pixel_size;
	pixel_screen_coord =  ivec2(floor(xx) * pixel_size,  floor(yy) * pixel_size);
	*/
	
	int xc = size.x/2 +  int(100 * cos(PI_2 * (4 * time) ));
	int yc = size.y/2 +  int(size.y *  cos(PI_2  * time ) );

	float period_x = 1./frequency.x;
	float period_y = 1./frequency.y;

	float Y = pixel_screen_coord.y/(size.y - 1.) *  period_x; // 

	vec4 inPixel = imageLoad(u_input_image, pixel_screen_coord);

	int x =  int( pixel_screen_coord.x + 100*    cos( PI_2 * frequency.x* (time + Y) )  ) ;

	float X = pixel_screen_coord.x/(size.x - 1.) *  period_y; // 

	int y =  int( pixel_screen_coord.y + 150 *    sin( PI_2 * frequency.x* (time + X) )  ) ;
	
	float phase = cos( PI_2 * 2 * time - 0.015 *sqrt(  (x-xc)*(x-xc)  +  (y-yc)*(y-yc) ) );

	x += int(20*phase);
	y += int(2 * phase);

	if ( x >= size.x)
	{
		x -= size.x;
	}
	else if ( x < 0) 
	{
	 	x = size.x + x;
	}

	if ( y >= size.y)
	{
		y -= size.y;
	}
	else if ( y < 0) 
	{
	 	y = size.y + y;
	}


	//imageStore(u_output_image , ivec2(x,y), vec4(0,0,0,0) );
	
	float depth =  1 - 0.40 *phase ;
	imageStore(u_output_image , ivec2(x,y), inPixel* depth );

}
 
 